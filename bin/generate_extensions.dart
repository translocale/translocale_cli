#!/usr/bin/env dart

import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:args/args.dart';

void main(List<String> args) async {
  final parser = ArgParser()
    ..addOption('source-file',
        help: 'Path to the source AppLocalizations class file', mandatory: true)
    ..addOption('output-file',
        help: 'Path for the generated extensions file', mandatory: true)
    ..addOption('class-name',
        help: 'Name for the generated extensions class',
        defaultsTo: 'AppLocalizationsOta');

  try {
    final results = parser.parse(args);

    final sourceFile = results['source-file'] as String;
    final outputFile = results['output-file'] as String;
    final className = results['class-name'] as String;

    await generateExtensions(
      sourceFilePath: sourceFile,
      outputPath: outputFile,
      className: className,
    );
  } catch (e) {
    print('Error: $e');
    print('Usage:');
    print(parser.usage);
    exit(1);
  }
}

Future<void> generateExtensions({
  required String sourceFilePath,
  required String outputPath,
  String className = 'AppLocalizationsOta',
}) async {
  print('üîÑ Generating extension methods...');
  print('Source file: $sourceFilePath');
  print('Output file: $outputPath');

  final sourceFile = File(sourceFilePath);
  if (!await sourceFile.exists()) {
    throw FileSystemException('Source file not found', sourceFilePath);
  }

  // Read the source file
  final sourceContent = await sourceFile.readAsString();

  // Parse the source file to extract method names and keys
  final methods = _extractMethods(sourceContent);

  // Check if any methods need to be converted to camelCase
  final needsConversion = methods.any((method) => method.name.contains('_'));
  if (needsConversion) {
    print(
        '‚ÑπÔ∏è Converting snake_case method names to lowerCamelCase for extension methods to comply with linting rules');
  }

  // Generate the extension methods
  final buffer = StringBuffer();

  // Add file header
  buffer.writeln('// Generated by TransLocale - do not modify by hand');
  buffer.writeln('// TransLocale OTA Extensions for Flutter Gen-L10n');
  buffer.writeln();

  // Add imports
  buffer.writeln("import 'package:flutter/widgets.dart';");
  buffer.writeln(
      "import 'package:translocale_flutter/translocale_flutter.dart';");

  // Import the app localizations - use a relative path based on output file
  buffer.writeln(
      "import '${p.relative(sourceFilePath, from: p.dirname(outputPath))}';");
  buffer.writeln();

  // Add extension class
  buffer.writeln('/// TransLocale OTA extensions for AppLocalizations');
  buffer.writeln('extension $className on AppLocalizations {');

  // Add lookup method
  buffer
      .writeln('  /// Lookup function to map method names to translation keys');
  buffer.writeln('  static String lookupKey(String methodName) {');
  buffer.writeln('    switch (methodName) {');

  for (final method in methods) {
    buffer.writeln('      case "${method.name}": return "${method.key}";');

    // Add an entry for the camelCase version if it's different from the original
    final camelCaseName = _toCamelCase(method.name);
    if (camelCaseName != method.name) {
      buffer.writeln('      case "$camelCaseName": return "${method.key}";');
    }
  }

  buffer.writeln('      default: return methodName;');
  buffer.writeln('    }');
  buffer.writeln('  }');
  buffer.writeln();

  // Add OTA methods for each original method
  for (final method in methods) {
    // Convert method name to camelCase if it contains underscores
    final otaMethodName = _toCamelCase(method.name);

    buffer.writeln('  /// OTA version of ${method.name}');

    if (method.hasParameters) {
      // Method with parameters
      buffer.writeln('  String ${otaMethodName}Ota(${method.parameters}) {');
      buffer.writeln(
          '    final otaValue = TransLocaleDelegateWrapper.getOtaTranslation("${method.key}");');
      buffer.writeln('    if (otaValue != null) {');

      // Handle parameters in the OTA string
      if (method.parameterNames.isNotEmpty) {
        buffer.writeln('      String result = otaValue;');
        for (final param in method.parameterNames) {
          buffer.writeln(
              '      result = result.replaceAll("{$param}", $param.toString());');
        }
        buffer.writeln('      return result;');
      } else {
        buffer.writeln('      return otaValue;');
      }

      buffer.writeln('    }');
      buffer.writeln(
          '    return ${method.name}(${method.parameterNames.join(", ")});');
      buffer.writeln('  }');
    } else {
      // Simple getter
      buffer.writeln('  String get ${otaMethodName}Ota {');
      buffer.writeln(
          '    final otaValue = TransLocaleDelegateWrapper.getOtaTranslation("${method.key}");');
      buffer.writeln('    return otaValue ?? ${method.name};');
      buffer.writeln('  }');
    }

    buffer.writeln();
  }

  buffer.writeln('}');

  // Write to file
  final outputFileObj = File(outputPath);
  final directory = outputFileObj.parent;

  if (!await directory.exists()) {
    await directory.create(recursive: true);
  }

  await outputFileObj.writeAsString(buffer.toString());
  print('‚úÖ Generated extension methods at $outputPath');
}

/// Extracts methods from the source file
List<_MethodInfo> _extractMethods(String sourceContent) {
  // This is a simplified implementation
  // In a real-world scenario, we would use a proper Dart parser
  final methods = <_MethodInfo>[];
  final lines = sourceContent.split('\n');

  // Regular expression to extract parameter names from method
  final paramNameRegex = RegExp(r'(\w+)\s*(?::\s*[^,\)]+)?');

  // Regular expression to extract the actual Translocale key from comments
  final keyRegex = RegExp(r'Auto-generated from Translocale key: ([^\n\*]*)');

  for (var i = 0; i < lines.length; i++) {
    final line = lines[i].trim();

    // Look for getter methods (String get methodName)
    if (line.startsWith('String get ')) {
      final nameEnd = line.indexOf(';');
      if (nameEnd > 0) {
        final name = line.substring('String get '.length, nameEnd).trim();

        // Check for key in nearby comments
        String? key;
        for (var j = i - 5; j < i; j++) {
          if (j >= 0 && lines[j].contains('///')) {
            final commentLine = lines[j].trim();
            final keyMatch = keyRegex.firstMatch(commentLine);
            if (keyMatch != null && keyMatch.groupCount >= 1) {
              key = keyMatch.group(1)?.trim();
              if (key != null) break;
            }
          }
        }

        methods.add(_MethodInfo(
          name: name,
          key: key ?? name, // Fallback to method name if key not found
          hasParameters: false,
          parameters: '',
          parameterNames: [],
        ));
      }
    }

    // Look for methods with parameters (String methodName(params))
    if (line.startsWith('String ') &&
        line.contains('(') &&
        line.contains(')') &&
        !line.contains(' get ')) {
      final nameStart = 'String '.length;
      final nameEnd = line.indexOf('(');
      if (nameEnd > nameStart) {
        final name = line.substring(nameStart, nameEnd);
        final paramEnd = line.indexOf(')');

        if (paramEnd > nameEnd) {
          final params = line.substring(nameEnd + 1, paramEnd);

          // Extract parameter names using regex for better accuracy
          final paramNames = <String>[];
          final paramMatches = paramNameRegex.allMatches(params);
          for (var match in paramMatches) {
            final paramName = match.group(1);
            if (paramName != null &&
                paramName.isNotEmpty &&
                ![
                  'String',
                  'int',
                  'double',
                  'bool',
                  'num',
                  'dynamic',
                  'var',
                  'void'
                ].contains(paramName)) {
              paramNames.add(paramName);
            }
          }

          // For the clean parameters string, preserve the original format
          final cleanParams = params.replaceAll(RegExp(r'\s*=\s*[^,\)]+'), '');

          // Check for key in nearby comments
          String? key;
          for (var j = i - 5; j < i; j++) {
            if (j >= 0 && lines[j].contains('///')) {
              final commentLine = lines[j].trim();
              final keyMatch = keyRegex.firstMatch(commentLine);
              if (keyMatch != null && keyMatch.groupCount >= 1) {
                key = keyMatch.group(1)?.trim();
                if (key != null) break;
              }
            }
          }

          methods.add(_MethodInfo(
            name: name,
            key: key ?? name, // Fallback to method name if key not found
            hasParameters: true,
            parameters: cleanParams,
            parameterNames: paramNames,
          ));
        }
      }
    }
  }

  return methods;
}

/// Information about a method
class _MethodInfo {
  final String name;
  final String key;
  final bool hasParameters;
  final String parameters;
  final List<String> parameterNames;

  _MethodInfo({
    required this.name,
    required this.key,
    required this.hasParameters,
    required this.parameters,
    required this.parameterNames,
  });
}

/// Convert a string from snake_case to lowerCamelCase
String _toCamelCase(String input) {
  if (!input.contains('_')) return input;

  final parts = input.split('_');
  final firstPart = parts.first.toLowerCase();
  final remainingParts = parts.skip(1).map((word) {
    if (word.isEmpty) return '';
    return word[0].toUpperCase() + word.substring(1).toLowerCase();
  }).join();

  return firstPart + remainingParts;
}
