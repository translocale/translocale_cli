import 'dart:convert';
import 'dart:io';

import 'package:args/args.dart';
import 'package:path/path.dart' as p;

void main(List<String> args) async {
  final parser = ArgParser()
    ..addOption('arb-dir', help: 'Directory containing the ARB files')
    ..addOption('output-dir',
        help: 'Directory where the generated files will be placed')
    ..addOption('template-arb-file',
        help: 'Template ARB file that defines all the strings')
    ..addOption('output-class',
        help: 'The output class name', defaultsTo: 'AppLocalizations')
    ..addFlag('help', abbr: 'h', help: 'Print this usage information');

  try {
    final results = parser.parse(args);

    if (results['help'] == true) {
      printUsage(parser);
      return;
    }

    final arbDir = results['arb-dir'] as String?;
    final outputDir = results['output-dir'] as String?;
    final templateArbFile = results['template-arb-file'] as String?;
    final outputClass = results['output-class'] as String?;

    if (arbDir == null ||
        outputDir == null ||
        templateArbFile == null ||
        outputClass == null) {
      print('Error: Missing required arguments');
      printUsage(parser);
      exit(1);
    }

    await generateOtaLocalizations(
      arbDir: arbDir,
      outputDir: outputDir,
      templateArbFile: templateArbFile,
      outputClass: outputClass,
    );
  } catch (e) {
    print('Error: $e');
    printUsage(parser);
    exit(1);
  }
}

void printUsage(ArgParser parser) {
  print(
      'Usage: dart bin/generate_ota_localizations.dart --arb-dir=<dir> --output-dir=<dir> --template-arb-file=<file> [--output-class=<name>]');
  print(parser.usage);
}

Future<void> generateOtaLocalizations({
  required String arbDir,
  required String outputDir,
  required String templateArbFile,
  required String outputClass,
}) async {
  print('Generating OTA localizations...');
  print('ARB directory: $arbDir');
  print('Output directory: $outputDir');
  print('Template ARB file: $templateArbFile');
  print('Output class: $outputClass');

  // Ensure the output directory exists
  Directory(outputDir).createSync(recursive: true);

  // Read the template ARB file
  final templateFile = File(p.join(arbDir, templateArbFile));
  if (!templateFile.existsSync()) {
    throw Exception('Template ARB file not found: ${templateFile.path}');
  }

  final templateJson =
      jsonDecode(templateFile.readAsStringSync()) as Map<String, dynamic>;

  // Parse the ARB file to extract translations and metadata
  final translations = <String, dynamic>{};
  final placeholders = <String, Set<String>>{};
  final pluralKeys = <String>{};

  // Process every entry in the template ARB file
  templateJson.forEach((key, value) {
    if (key.startsWith('@')) {
      // This is a metadata entry
      final messageKey = key.substring(1);
      final metadata = value as Map<String, dynamic>;

      if (metadata.containsKey('placeholders')) {
        // Extract placeholder names
        final placeholdersMap =
            metadata['placeholders'] as Map<String, dynamic>;
        placeholders[messageKey] = placeholdersMap.keys.toSet();
      }

      // Check if this is a plural message
      if (metadata.containsKey('type') && metadata['type'] == 'plural') {
        pluralKeys.add(messageKey);
      }
    } else if (!key.startsWith('_') && value is String) {
      // This is a translation key
      translations[key] = value;
    }
  });

  // Generate the proxy class
  await _generateOtaProxy(
    outputDir: outputDir,
    outputClass: outputClass,
    translations: translations,
    placeholders: placeholders,
    pluralKeys: pluralKeys,
  );

  // Generate the OTA delegate
  await _generateOtaDelegate(
    outputDir: outputDir,
    outputClass: outputClass,
  );

  print('OTA localizations generated successfully!');
}

Future<void> _generateOtaProxy({
  required String outputDir,
  required String outputClass,
  required Map<String, dynamic> translations,
  required Map<String, Set<String>> placeholders,
  required Set<String> pluralKeys,
}) async {
  final buffer = StringBuffer();

  buffer.writeln('''
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by the translocale generator

// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_string_interpolations

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:translocale/translocale.dart';

/// OTA proxy for $outputClass
///
/// This class is automatically generated to match the interface of
/// your app's generated localizations class. It handles forwarding
/// method calls to either the OTA translations or the original
/// build-time translations.
class Translocale${outputClass}Proxy implements $outputClass {
  final $outputClass _buildTimeDelegate;
  
  Translocale${outputClass}Proxy(this._buildTimeDelegate);
  
  @override
  String get localeName => _buildTimeDelegate.localeName;
  
  @override
  bool isSupported(Locale locale) => _buildTimeDelegate.isSupported(locale);
''');

  // Generate getters/methods for each translation
  translations.forEach((key, _) {
    if (placeholders.containsKey(key)) {
      // This is a method with parameters
      final placeholderNames = placeholders[key]!;
      final parameters =
          placeholderNames.map((name) => 'Object $name').join(', ');

      if (pluralKeys.contains(key)) {
        // This is a plural method
        buffer.writeln('''
  @override
  String $key($parameters) {
    final buildTimeValue = _buildTimeDelegate.$key($parameters);
    return Translocale.formatTranslation('$key', buildTimeValue, {
      ${placeholderNames.map((name) => "'$name': $name").join(', ')}
    });
  }
''');
      } else {
        // Regular method with parameters
        buffer.writeln('''
  @override
  String $key($parameters) {
    final buildTimeValue = _buildTimeDelegate.$key($parameters);
    return Translocale.formatTranslation('$key', buildTimeValue, {
      ${placeholderNames.map((name) => "'$name': $name").join(', ')}
    });
  }
''');
      }
    } else {
      // This is a simple getter
      buffer.writeln('''
  @override
  String get $key {
    final buildTimeValue = _buildTimeDelegate.$key;
    return Translocale.lookupTranslation('$key', buildTimeValue);
  }
''');
    }
  });

  buffer.writeln('}');

  // Write the generated code to a file
  final outputFile = File(p.join(outputDir, 'ota_proxy.dart'));
  await outputFile.writeAsString(buffer.toString());
  print('Generated OTA proxy: ${outputFile.path}');
}

Future<void> _generateOtaDelegate({
  required String outputDir,
  required String outputClass,
}) async {
  final buffer = StringBuffer();

  buffer.writeln('''
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by the translocale generator

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:translocale/translocale.dart';

import 'ota_proxy.dart';

/// Localization delegate that proxies between build-time and OTA translations
///
/// This delegate wraps the build-time delegate and forwards all calls
/// to the OTA proxy.
class Translocale${outputClass}Delegate extends LocalizationsDelegate<$outputClass> {
  final LocalizationsDelegate<$outputClass> _buildTimeDelegate;
  
  /// Create a new OTA delegate wrapping the build-time delegate
  const Translocale${outputClass}Delegate(this._buildTimeDelegate);
  
  @override
  bool isSupported(Locale locale) => _buildTimeDelegate.isSupported(locale);
  
  @override
  Future<$outputClass> load(Locale locale) async {
    final buildTimeLocalizations = await _buildTimeDelegate.load(locale);
    return Translocale${outputClass}Proxy(buildTimeLocalizations);
  }
  
  @override
  bool shouldReload(Translocale${outputClass}Delegate old) => 
      _buildTimeDelegate != old._buildTimeDelegate;
}
''');

  // Write the generated code to a file
  final outputFile = File(p.join(outputDir, 'ota_delegate.dart'));
  await outputFile.writeAsString(buffer.toString());
  print('Generated OTA delegate: ${outputFile.path}');
}
